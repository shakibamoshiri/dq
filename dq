#!/usr/bin/env node

NODE_DISABLE_COLORS=1

const http = require('http');
const util = require('util');
const R    = require( 'ramda' );

const commander = require('commander'); // (normal include)
const cli = new commander.Command();

const log = console.log.bind( console );
console.time('time');


const CLI_VERSION='1.0.0';

const dockerApi = {
    socketPath: '/var/run/docker.sock',
    containerPath: '/containers/json?all=1',
    networkPath: '/networks'
};

function sendRequest( url ){
    return new Promise(function( resolve, reject ){
    http.request(
        {
          socketPath: dockerApi.socketPath,
          path: url
        },
        function( response ){
            const statusCode = response.statusCode;
            // log( statusCode );
            if( ! statusCode == 200 ){
                log( `Error in response: ${statusCode}` );
                reject( `Error in response: ${statusCode}` );
            }
            let allCon = '';
            response.on( 'data', function( data ){
                allCon += data;
            })

            response.on( 'close', function( code ){
                resolve( allCon );
            })
        })
    .end();
    })
}

function printf( text, space  ) {
    text = text + " ";
    try{ 
        text = text + ( " ".repeat( ( space - text.length ) ) );
    } catch( error ){
        log( error.message );
        log( `The length ${space} is not enough` );
        log( 'Please increase space with -p | --pad <number>' );
        process.exit(0);
    }
    return text;
}

function listOfQuery(){
    const list = {
        name: '.Name',
        ip: '.NetworkSettings.IPAddress',
        ports: '.NetworkSettings.Ports',
        'ports.con': '.NetworkSettings.Ports',
        'ports.host': '.NetworkSettings.Ports',
        hostports: '.NetworkSettings.Ports',
        gateway: '.NetworkSettings.Gateway',
        image: '.Config.Image',
        cmd: '.Config.Cmd',
        status: '.State.Status',
        hostname: '.Config.Hostname',
        pid: '.State.pid',
        exit: '.State.ExitCode',
        exitcode: '.State.ExitCode',
        net: '.NetworkSettings.Networks',
        network: '.NetworkSettings.Networks'
    };

    log( list );
}

function moreAboutMe(){
    log(`version: ${CLI_VERSION}
Author: Shakiba Moshiri
Repository: https://...  `);
}

(async function(){
    const allContainers = await sendRequest( dockerApi.containerPath );

    const containers =
    JSON.parse( allContainers )
    .map(function( con ){
        return con.Id;

    }).map(function( id ){
        return `/containers/${id}/json`;

    }).map(async function( containerApiPath ){
        const c = await sendRequest( containerApiPath );
        const r = JSON.parse( c );
        return r;
    });

    const networkJson = await sendRequest( dockerApi.networkPath );
    const listOfnetworks = JSON.parse( networkJson );

    let SPACE_LENGTH;

    cli
        .option('-q, --query <value...>', 'a query, e.g. name status pid ip')
        .option('-p, --pad <number>', 'a number for padding', 1 )
        .option('-t, --table', 'output in table format')
        .option('-l, --list', 'list of queries')
        .option('-v, --version', 'version' )
        ;

    cli.parse(process.argv);
    const options = cli.opts();


    if( options.list ){
        listOfQuery();
        process.exit( 0 );
    }

    if( options.version ){
        moreAboutMe();
        process.exit( 0 );
    }

    if (!options.query) log( cli.help());
    if(options.pad){
        SPACE_LENGTH = parseInt( options.pad);
    }

    const queries = options.query;
    
    const tableArray = [];
    const logArray = [];
    let table = {};
    let array = [];

    for( con of containers ){
        await con.then(async function( json ){
            for( query of queries ){
                switch( query ){
                    case 'image':
                        const image = json.Config.Image;
                        array.push( image );
                        table[ query ] = image;
                    break;
                    case 'ip':
                        const tip = json.NetworkSettings.Networks;
                        array.push( tip );
                        const ip = Object.values( tip ).map(function( net ){
                            return net.IPAddress;
                        })
                        table[ query ] = ip;
                    break;
                    case 'gw':
                    case 'gateway':
                        const tgw = Object.keys( json.NetworkSettings.Networks );

                        const gw =
                        tgw.map(function( mine ){
                            return listOfnetworks.filter(function( net ){
                                return net.Name == mine;
                            })
                        }).flat()
                        .map(function( net ){
                            return net.IPAM.Config;
                        }).flat()
                        .map(function( net ){
                            return net.Gateway;
                        }).flat();

                        table[ query ] = gw;
                    break;
                    case 'subnet':
                        const tsubnet = Object.keys( json.NetworkSettings.Networks );

                        const subnet =
                        tsubnet.map(function( mine ){
                            return listOfnetworks.filter(function( net ){
                                return net.Name == mine;
                            })
                        }).flat()
                        .map(function( net ){
                            return net.IPAM.Config;
                        }).flat()
                        .map(function( net ){
                            return net.Subnet;
                        }).flat();

                        table[ query ] = subnet;
                    break;
                    case 'scope':
                        const tscope = Object.keys( json.NetworkSettings.Networks );
                        const scope =
                        tscope.map(function( mine ){
                            return listOfnetworks.filter(function( net ){
                                return net.Name == mine;
                            })
                        }).flat()
                        .map(function( net ){
                            return net.Scope;
                        })
                        table[ query ] = scope;
                    break;
                    case 'mac':
                    case 'macaddress':
                        const tmac = json.NetworkSettings.Networks;
                        array.push( tmac );
                        const mac = Object.values( tmac ).map(function( net ){
                            return net.MacAddress;
                        })
                        table[ query ] = mac;
                    break;
                    case 'cmd':
                        const cmd = json.Config.Cmd.join(' ')
                        array.push( cmd );
                        table[ query ] = cmd
                    break;
                    case 'hostname':
                        const hostname = json.Config.Hostname;
                        array.push( hostname );
                        table[ query ] = hostname;
                    break;
                    case 'id':
                        const id = json.Id;
                        table[ query ] = id;
                    break;
                    case 'pid':
                        const pid = json.State.Pid;
                        array.push( pid );
                        table[ query ] = pid;
                    break;
                    case 'name':
                        const name = json.Name.substr(1);
                        array.push( name );
                        table[ query ] = name;
                    break;
                    case 'status':
                        const status = json.State.Status;
                        array.push( status );
                        table[ query ] = status;
                    break;
                    case 'ports':
                    case 'ports.con':
                        const ports =  Object.keys( json.NetworkSettings.Ports );
                        table[ query ] = ports;
                    break;
                    case 'hostports':
                    case 'ports.host':
                        const thostports = json.NetworkSettings.Ports;
                        const hostports =
                        R.pipe(
                            R.values,
                            R.flatten,
                            R.map( R.values ),
                            R.map( R.join(":"))
                        )(thostports);
                        table[ query ] = hostports;
                    break;
                    case 'exit':
                    case 'exitcode':
                        const exitcode = json.State.ExitCode;
                        table[ query ] = exitcode;
                    break;
                    case 'net':
                    case 'nets':
                    case 'network':
                    case 'networks':
                        const networks = Object.keys( json.NetworkSettings.Networks );


                        table[ query ] = networks;
                    break;
                    default:
                        table[ query ] = '?';
                }
            }
            tableArray.push( table );
            table = {};
            logArray.push( array );
            array = [];
        })
    }
    if( options.table ){
        console.table( tableArray );
    } else {

        // max size of each column should be determined
        const tableSize = {};
        for( q of queries ){
            let maxLength = 0;
            for( obj of tableArray ){
                const length = String( obj[ q ] ).length;
                if( length > maxLength ){
                    maxLength = length;
                }
            }
            tableSize[ q ] = maxLength;

            // edge case
            // when a column size is smaller than title size
            if( q.length > maxLength ){
                tableSize[ q ] = q.length;
            }
        }
        
        // print the table header
        for( q of queries ){
            const r = printf( q, tableSize[ q ] + SPACE_LENGTH );
            process.stdout.write( r );
        }
        process.stdout.write( "\n" );

        // print the table content
        for( obj of tableArray ){
            for( q of queries ){
                const r = printf( obj[ q ], tableSize[ q ] + SPACE_LENGTH );
                process.stdout.write( r );
            }
            process.stdout.write( "\n" );
        }
    }
    
    process.stdout.write( "\n" );
    console.timeEnd( 'time' );

// end of IIFE 
}());

